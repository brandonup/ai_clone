<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Clone - Chat</title> <!-- Title updated dynamically -->
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <div>
                <h1 id="clone-name-header">Loading...</h1>
                <div id="role-tag-header" class="role-tag" style="display: none;"></div>
            </div>
            <div class="header-actions">
                <!-- Link to frontend directory -->
                <a href="{{ url_for('clone_directory') }}" class="new-chat-btn">
                    <i class="fas fa-list"></i> Clone Directory
                </a>
                <!-- Manage Clone button -->
                <a href="{{ url_for('manage_clone_page', clone_id=initial_clone_id) }}" class="new-chat-btn">
                    <i class="fas fa-cog"></i> Manage Clone
                </a>
                <!-- Button handled by JS -->
                <button id="new-chat-button" class="new-chat-btn">
                    <i class="fas fa-plus"></i> New Chat
                </button>
            </div>
        </div>

        <div id="flash-messages" class="flash-messages" style="display: none;">
            <!-- JS will populate this -->
        </div>

        <div class="chat-messages" id="chat-messages">
            <!-- Messages will be loaded here by JavaScript -->
            <div id="empty-chat-state" class="empty-chat">
                 <div class="empty-chat-icon"><i class="fas fa-comments"></i></div>
                 <h2 id="empty-chat-title">Welcome!</h2>
                 <p>Ask a question to start the conversation.</p>
            </div>
             <div id="loading-chat-state" class="loading-state" style="display: none;">Loading chat...</div>
        </div>

        <div class="chat-input">
            <form id="chat-form">
                <div class="input-container">
                    <textarea name="question" id="question" rows="1" placeholder="Ask a question..." required disabled></textarea>
                    <button type="submit" id="send-button" class="send-btn" disabled>
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </form>
        </div>
    </div>

    <script>
        const backendApiUrl = "{{ backend_api_url }}";
        const initialCloneId = "{{ initial_clone_id or '' }}";
        const initialCloneName = "{{ initial_clone_name or 'Clone' }}";
        const initialCloneRole = "{{ initial_clone_role or '' }}";
        const initialConversationId = "{{ initial_conversation_id or '' }}";

        const chatMessagesContainer = document.getElementById('chat-messages');
        const chatForm = document.getElementById('chat-form');
        const questionTextarea = document.getElementById('question');
        const sendButton = document.getElementById('send-button');
        const newChatButton = document.getElementById('new-chat-button');
        const cloneNameHeader = document.getElementById('clone-name-header');
        const roleTagHeader = document.getElementById('role-tag-header');
        const emptyChatState = document.getElementById('empty-chat-state');
        const emptyChatTitle = document.getElementById('empty-chat-title');
        const loadingChatState = document.getElementById('loading-chat-state');
        const flashMessagesContainer = document.getElementById('flash-messages');

        let currentConversationId = initialConversationId;
        let currentCloneName = initialCloneName;

        function displayFlashMessage(message, type = 'error') {
            flashMessagesContainer.innerHTML = '';
            const messageDiv = document.createElement('div');
            messageDiv.className = `flash-message flash-${type}`;
            messageDiv.textContent = message;
            flashMessagesContainer.appendChild(messageDiv);
            flashMessagesContainer.style.display = 'block';
            window.scrollTo(0, 0);
        }

        function scrollToBottom() {
            // A small delay can sometimes help ensure rendering is complete
            setTimeout(() => {
                chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
            }, 50);
        }

        function renderMessage(message) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message');

            const contentDiv = document.createElement('div');
            contentDiv.classList.add('message-content');

            const avatarDiv = document.createElement('div');
            avatarDiv.classList.add('message-avatar');
            const avatarIcon = document.createElement('i');
            avatarIcon.classList.add('fas');

            const textDiv = document.createElement('div');
            textDiv.classList.add('message-text');
            const textP = document.createElement('p');
            // Basic rendering, consider Markdown/sanitization later if needed
            textP.textContent = message.content || '';
            textDiv.appendChild(textP);

            if (message.role === 'user') {
                messageDiv.classList.add('user-message');
                avatarIcon.classList.add('fa-user');
            } else { // assistant
                messageDiv.classList.add('assistant-message');
                avatarIcon.classList.add('fa-robot');

                const infoDiv = document.createElement('div');
                infoDiv.classList.add('message-info');

                if (message.source) {
                    const sourceSpan = document.createElement('span');
                    sourceSpan.classList.add('source-tag');
                    sourceSpan.textContent = `Source: ${message.source}`;
                    infoDiv.appendChild(sourceSpan);
                }
                if (message.timestamp) {
                    const timeSpan = document.createElement('span');
                    timeSpan.classList.add('message-timestamp');
                    // Attempt to format timestamp nicely, fallback to original
                    try {
                        timeSpan.textContent = new Date(message.timestamp).toLocaleString();
                    } catch (e) {
                        timeSpan.textContent = message.timestamp;
                    }
                    infoDiv.appendChild(timeSpan);
                }
                // Append infoDiv only if it has content
                if (infoDiv.hasChildNodes()) {
                    textDiv.appendChild(infoDiv);
                }

                // Display prompt composition if available
                if (message.prompt_composition) {
                    const detailsDiv = document.createElement('details');
                    detailsDiv.classList.add('prompt-composition-details');

                    const summary = document.createElement('summary');
                    summary.textContent = 'Show Prompt Details';
                    detailsDiv.appendChild(summary);

                    const compositionContainer = document.createElement('div');
                    compositionContainer.classList.add('prompt-composition-container');
                    const compositionText = message.prompt_composition || '';

                    // Split by the double newline *before* a header line.
                    const sections = compositionText.split(/\n\n(?=== .* ===)/g);

                    sections.forEach((sectionText, index) => {
                        const trimmedSection = sectionText.trim();
                        if (!trimmedSection) return;

                        const sectionDiv = document.createElement('div');
                        sectionDiv.classList.add('prompt-section');

                        const headerMatch = trimmedSection.match(/^(=== .* ===)\n?/);
                        let contentText = trimmedSection;

                        if (headerMatch) {
                            const headerText = headerMatch[1];
                            const headerDiv = document.createElement('div');
                            headerDiv.classList.add('prompt-section-header');
                            headerDiv.textContent = headerText;
                            sectionDiv.appendChild(headerDiv);
                            contentText = trimmedSection.substring(headerMatch[0].length).trim();
                        }

                        if (contentText) {
                            const contentPre = document.createElement('pre');
                            contentPre.classList.add('prompt-section-content');
                            contentPre.textContent = contentText;
                            sectionDiv.appendChild(contentPre);
                        }

                        compositionContainer.appendChild(sectionDiv);

                        // Add divider *before* the next section (except for the first one)
                        if (index > 0) {
                             const hr = document.createElement('hr');
                             hr.classList.add('prompt-section-divider');
                             compositionContainer.insertBefore(hr, sectionDiv);
                        }
                    });

                    // Fallback if splitting resulted in nothing
                    if (compositionContainer.children.length === 0 && compositionText) {
                         const fallbackDiv = document.createElement('div');
                         fallbackDiv.classList.add('prompt-section');
                         const fallbackPre = document.createElement('pre');
                         fallbackPre.classList.add('prompt-section-content');
                         fallbackPre.textContent = compositionText.trim();
                         fallbackDiv.appendChild(fallbackPre);
                         compositionContainer.appendChild(fallbackDiv);
                    }

                    detailsDiv.appendChild(compositionContainer);
                    textDiv.appendChild(detailsDiv);
                }
            }

            avatarDiv.appendChild(avatarIcon);
            contentDiv.appendChild(avatarDiv);
            contentDiv.appendChild(textDiv);
            messageDiv.appendChild(contentDiv);

            // Remove empty state before adding messages
            emptyChatState.classList.remove('empty-chat--visible');
            chatMessagesContainer.appendChild(messageDiv);
        }

        function renderHistory(history) {
            console.log(`Rendering history. Length: ${history ? history.length : 'null/undefined'}`);
            // Clear existing messages
            const messagesToRemove = chatMessagesContainer.querySelectorAll('.message.user-message, .message.assistant-message');
            messagesToRemove.forEach(msg => msg.remove());

            loadingChatState.style.display = 'none';
            emptyChatState.classList.remove('empty-chat--visible'); // Hide by default

            if (!history || history.length === 0) {
                emptyChatTitle.textContent = `Welcome to Clone ${currentCloneName || 'Chat'}`;
                emptyChatState.classList.add('empty-chat--visible'); // Show if history is empty
                console.log("History empty, showing empty state.");
            } else {
                console.log("Rendering messages from history...");
                history.forEach(renderMessage);
            }
            scrollToBottom();
        }

        // Handle Form Submission (Send Message)
        chatForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            console.log('[Submit Listener] Form submission triggered.');
            const question = questionTextarea.value.trim();
            if (!question || !currentConversationId) {
                console.warn("Empty question or missing conversation ID. Aborting submit.");
                return;
            }

            // Optimistically render user message
            const userMessage = { role: 'user', content: question, timestamp: new Date().toISOString() }; // Use ISO string for consistency
            renderMessage(userMessage);
            scrollToBottom();

            // Clear input and disable form
            const originalHeight = questionTextarea.style.height; // Store original height
            questionTextarea.value = '';
            questionTextarea.style.height = originalHeight; // Restore height after clearing
            questionTextarea.disabled = true;
            sendButton.disabled = true;

            // Show thinking indicator
            const thinkingDiv = document.createElement('div');
            thinkingDiv.className = 'message assistant-message thinking'; // Unique class
            thinkingDiv.innerHTML = '<div class="message-content"><div class="message-avatar"><i class="fas fa-robot"></i></div><div class="message-text"><p><i>Thinking...</i></p></div></div>';
            chatMessagesContainer.appendChild(thinkingDiv);
            scrollToBottom();

            try {
                const response = await fetch(`${backendApiUrl}/api/ask`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        question: question, 
                        clone_id: initialCloneId,
                        conversation_id: currentConversationId 
                    }), // Send clone_id and conversation_id
                    credentials: 'include'
                });

                // Remove thinking indicator *before* processing response
                const currentThinkingIndicator = chatMessagesContainer.querySelector('.thinking'); // Query again inside try
                if (currentThinkingIndicator) {
                    currentThinkingIndicator.remove();
                }

                if (!response.ok) {
                    let errorMsg = `Error ${response.status}: Failed to get response from clone.`;
                    try {
                        const errorResult = await response.json();
                        errorMsg = errorResult.error || errorMsg;
                    } catch (jsonError) {
                        console.warn("Could not parse error response as JSON.");
                    }
                    console.error('Error asking question:', errorMsg);
                    displayFlashMessage(errorMsg, 'error');
                    // Consider removing the optimistic user message here if desired
                } else {
                    const result = await response.json();
                    console.log("Received response from /api/ask:", result);
                    // Re-render the entire history from the response
                    renderHistory(result.conversation_history || []);
                }

            } catch (error) {
                console.error('Network or other error sending message:', error);
                 // Ensure thinking indicator is removed on network error too
                const currentThinkingIndicator = chatMessagesContainer.querySelector('.thinking'); // Query again inside catch
                if (currentThinkingIndicator) {
                    currentThinkingIndicator.remove();
                }
                displayFlashMessage('A network error occurred while sending your message.', 'error');
            } finally {
                // Re-enable form
                questionTextarea.disabled = false;
                sendButton.disabled = false;
                questionTextarea.focus();
                // Adjust height again in case content caused scrollbars during disable
                questionTextarea.dispatchEvent(new Event('input'));
            }
        });

        // Handle New Chat Button
        newChatButton.addEventListener('click', async () => {
            console.log("Starting new chat...");
            newChatButton.disabled = true;
            flashMessagesContainer.style.display = 'none';

            if (!backendApiUrl) {
                 displayFlashMessage('Error: Backend API URL not configured.');
                 newChatButton.disabled = false;
                 return;
            }

            try {
                 const response = await fetch(`${backendApiUrl}/api/new_chat`, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     credentials: 'include'
                 });
                 const result = await response.json();

                 if (response.ok) {
                     console.log("New chat started:", result);
                     currentConversationId = result.conversation_id; // Update conversation ID
                     renderHistory([]); // Clear the chat display and show empty state
                     questionTextarea.disabled = false;
                     sendButton.disabled = false;
                     questionTextarea.focus();
                 } else {
                     console.error("Failed to start new chat:", result);
                     displayFlashMessage(result.error || 'Failed to start new chat.', 'error');
                 }
            } catch (error) {
                 console.error("Network error starting new chat:", error);
                 displayFlashMessage('A network error occurred while starting a new chat.', 'error');
            } finally {
                 newChatButton.disabled = false;
            }
        });

        // --- Textarea Auto-Resize ---
        questionTextarea.addEventListener('input', function() {
            this.style.height = 'auto'; // Temporarily shrink
            this.style.height = (this.scrollHeight) + 'px'; // Set to scroll height
        });

        // --- Submit on Enter (without Shift) ---
        questionTextarea.addEventListener('keydown', function(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault(); // Prevent newline
                // Check if textarea is not empty before submitting
                if (questionTextarea.value.trim()) {
                    console.log('[Keydown Listener] Enter pressed, submitting form.');
                    chatForm.requestSubmit(); // Use standard form submission trigger
                } else {
                    console.log('[Keydown Listener] Enter pressed, but textarea is empty.');
                }
            }
        });

        // --- Initial Page Load Logic ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log('[Chat Interface] DOMContentLoaded fired.');
            if (!initialCloneId || !initialConversationId) {
                console.error("Missing initial clone/conversation ID. Redirecting.");
                window.location.href = "{{ url_for('clone_directory') }}"; // Redirect if essential info missing
                return;
            }

            // Set initial state from template variables
            currentConversationId = initialConversationId;
            currentCloneName = initialCloneName;
            document.title = `Clone ${currentCloneName} - Chat`;
            cloneNameHeader.textContent = currentCloneName;
            if (initialCloneRole) {
                roleTagHeader.textContent = initialCloneRole;
                roleTagHeader.style.display = 'block';
            } else {
                roleTagHeader.style.display = 'none';
            }

            // Show loading state and disable input initially
            loadingChatState.style.display = 'block';
            emptyChatState.classList.remove('empty-chat--visible');
            questionTextarea.disabled = true;
            sendButton.disabled = true;

            // Function to load initial history
            async function loadInitialHistory() {
                console.log(`Attempting to load history for conversation: ${currentConversationId}`);
                if (!currentConversationId) {
                    console.log("No initial conversation ID, rendering empty state.");
                    renderHistory([]); // Render empty state if no ID
                    loadingChatState.style.display = 'none';
                    questionTextarea.disabled = false;
                    sendButton.disabled = false;
                    questionTextarea.focus();
                    return;
                }

                try {
                    // --- TODO: Ensure this backend endpoint exists and returns history ---
                    // Example endpoint: /api/conversation_history/{conversation_id}
                    const response = await fetch(`${backendApiUrl}/api/conversation_history/${currentConversationId}`, {
                        method: 'GET',
                        headers: { 'Accept': 'application/json' },
                        credentials: 'include'
                    });

                    loadingChatState.style.display = 'none'; // Hide loading indicator

                    if (!response.ok) {
                        let errorMsg = `Error ${response.status}: Failed to load conversation history.`;
                        try {
                            const errorResult = await response.json();
                            errorMsg = errorResult.error || errorMsg;
                        } catch (jsonError) { /* Ignore if error response isn't JSON */ }
                        console.error(errorMsg);
                        displayFlashMessage(errorMsg, 'error');
                        renderHistory([]); // Show empty state on error
                    } else {
                        const result = await response.json();
                        console.log("Received initial history:", result);
                        renderHistory(result.conversation_history || []); // Render fetched history
                    }
                } catch (error) {
                    console.error('Network or other error loading initial history:', error);
                    loadingChatState.style.display = 'none';
                    displayFlashMessage('A network error occurred while loading the chat history.', 'error');
                    renderHistory([]); // Show empty state on network error
                } finally {
                    // Re-enable form regardless of history load success/failure
                    questionTextarea.disabled = false;
                    sendButton.disabled = false;
                    questionTextarea.focus();
                    // Adjust height in case content caused scrollbars
                    questionTextarea.dispatchEvent(new Event('input'));
                }
            }

            // Load the initial history
            loadInitialHistory();
            // --- End of initial history loading ---

            console.log(`Chat interface initialized for Clone ID: ${initialCloneId}, Conversation ID: ${initialConversationId}`);
        });

    </script>
</body>
</html>
