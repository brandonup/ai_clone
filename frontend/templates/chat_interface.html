<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Clone - Chat</title> <!-- Title updated dynamically -->
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <div>
                <h1 id="clone-name-header">Loading...</h1>
                <div id="role-tag-header" class="role-tag" style="display: none;"></div>
            </div>
            <div class="header-actions">
                 <!-- Link to frontend directory -->
                <a href="{{ url_for('clone_directory') }}" class="new-chat-btn">
                    <i class="fas fa-list"></i> Clone Directory
                </a>
                 <!-- Button handled by JS -->
                <button id="new-chat-button" class="new-chat-btn">
                    <i class="fas fa-plus"></i> New Chat
                </button>
            </div>
        </div>

        <div id="flash-messages" class="flash-messages" style="display: none;">
            <!-- JS will populate this -->
        </div>

        <div class="chat-messages" id="chat-messages">
            <!-- Messages will be loaded here by JavaScript -->
            <div id="empty-chat-state" class="empty-chat"> <!-- REMOVED style="display: none;" -->
                 <div class="empty-chat-icon"><i class="fas fa-comments"></i></div>
                 <h2 id="empty-chat-title">Welcome!</h2>
                 <p>Ask a question to start the conversation.</p>
            </div>
             <div id="loading-chat-state" class="loading-state">Loading chat...</div>
        </div>

        <div class="chat-input">
             <!-- Removed action and method -->
            <form id="chat-form">
                <div class="input-container">
                    <textarea name="question" id="question" rows="1" placeholder="Ask a question..." required disabled></textarea>
                    <button type="submit" id="send-button" class="send-btn" disabled>
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </form>
        </div>
    </div>

    <script>
        const backendApiUrl = "{{ backend_api_url }}"; // Get URL from Flask
        // Get initial clone info passed from Flask template context
        const initialCloneId = "{{ initial_clone_id or '' }}";
        const initialCloneName = "{{ initial_clone_name or 'Clone' }}";
        const initialCloneRole = "{{ initial_clone_role or '' }}";
        const initialConversationId = "{{ initial_conversation_id or '' }}"; // <<< GET CONVERSATION ID

        const chatMessagesContainer = document.getElementById('chat-messages');
        const chatForm = document.getElementById('chat-form');
        const questionTextarea = document.getElementById('question');
        const sendButton = document.getElementById('send-button');
        const newChatButton = document.getElementById('new-chat-button');
        const cloneNameHeader = document.getElementById('clone-name-header');
        const roleTagHeader = document.getElementById('role-tag-header');
        const emptyChatState = document.getElementById('empty-chat-state');
        const emptyChatTitle = document.getElementById('empty-chat-title');
        const loadingChatState = document.getElementById('loading-chat-state');
        const flashMessagesContainer = document.getElementById('flash-messages');

        let currentConversationId = initialConversationId; // <<< SET INITIAL CONVERSATION ID
        let currentCloneName = initialCloneName; // Use initial name

        function displayFlashMessage(message, type = 'error') {
            flashMessagesContainer.innerHTML = ''; // Clear previous
            const messageDiv = document.createElement('div');
            messageDiv.className = `flash-message flash-${type}`;
            messageDiv.textContent = message;
            flashMessagesContainer.appendChild(messageDiv);
            flashMessagesContainer.style.display = 'block';
            window.scrollTo(0, 0);
        }

        function scrollToBottom() {
            chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
        }

        function renderMessage(message) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message');

            const contentDiv = document.createElement('div');
            contentDiv.classList.add('message-content');

            const avatarDiv = document.createElement('div');
            avatarDiv.classList.add('message-avatar');
            const avatarIcon = document.createElement('i');
            avatarIcon.classList.add('fas');

            const textDiv = document.createElement('div');
            textDiv.classList.add('message-text');
            const textP = document.createElement('p');
            textP.textContent = message.content; // Basic text rendering
             // Consider using a library like 'marked' or 'DOMPurify' if you expect Markdown or need sanitization
            textDiv.appendChild(textP);

            if (message.role === 'user') {
                messageDiv.classList.add('user-message');
                avatarIcon.classList.add('fa-user');
            } else { // assistant
                messageDiv.classList.add('assistant-message');
                avatarIcon.classList.add('fa-robot');

                const infoDiv = document.createElement('div');
                infoDiv.classList.add('message-info');

                if (message.source) {
                    const sourceSpan = document.createElement('span');
                    sourceSpan.classList.add('source-tag');
                    sourceSpan.textContent = `Source: ${message.source}`;
                    infoDiv.appendChild(sourceSpan);
                }
                if (message.timestamp) {
                    const timeSpan = document.createElement('span');
                    timeSpan.classList.add('message-timestamp');
                    timeSpan.textContent = message.timestamp;
                    infoDiv.appendChild(timeSpan);
                }
                textDiv.appendChild(infoDiv);

                // Display prompt composition if available
                if (message.prompt_composition) {
                    const detailsDiv = document.createElement('details');
                    detailsDiv.classList.add('prompt-composition-details'); // Add class for styling

                    const summary = document.createElement('summary');
                    summary.textContent = 'Show Prompt Details';
                    detailsDiv.appendChild(summary);

                    // --- Render prompt composition in sections (Final Attempt) ---
                    const compositionContainer = document.createElement('div');
                    compositionContainer.classList.add('prompt-composition-container');
                    const compositionText = message.prompt_composition || '';

                    // Split by the double newline *before* a header line.
                    const sections = compositionText.split(/\n\n(?=== .* ===)/g);

                    sections.forEach(sectionText => {
                        const trimmedSection = sectionText.trim();
                        if (!trimmedSection) return; // Skip empty sections

                        const sectionDiv = document.createElement('div');
                        sectionDiv.classList.add('prompt-section'); // This div gets the bottom margin from CSS

                        // Check if this section starts with a header
                        const headerMatch = trimmedSection.match(/^(=== .* ===)\n?/);
                        let contentText = trimmedSection; // Assume all is content initially

                        if (headerMatch) {
                            // If header found, create header element
                            const headerText = headerMatch[1];
                            const headerDiv = document.createElement('div');
                            headerDiv.classList.add('prompt-section-header');
                            headerDiv.textContent = headerText;
                            sectionDiv.appendChild(headerDiv);

                            // Update contentText to be everything *after* the header line
                            contentText = trimmedSection.substring(headerMatch[0].length).trim();
                        }

                        // Create content element if there's any content left
                        if (contentText) {
                            const contentPre = document.createElement('pre');
                            contentPre.classList.add('prompt-section-content');
                            contentPre.textContent = contentText;
                            sectionDiv.appendChild(contentPre);
                        }

                        // Add the complete section (header + content) to the container
                        compositionContainer.appendChild(sectionDiv);
                        
                        // Add a horizontal rule after each section (except the last one, which we'll handle later)
                        const hr = document.createElement('hr');
                        hr.classList.add('prompt-section-divider');
                        compositionContainer.appendChild(hr);
                    });
                    
                    // Remove the last divider if it exists (we don't want a divider after the last section)
                    const dividers = compositionContainer.querySelectorAll('.prompt-section-divider');
                    if (dividers.length > 0) {
                        compositionContainer.removeChild(dividers[dividers.length - 1]);
                    }

                     // Fallback if splitting resulted in nothing (e.g., text has no headers)
                    if (compositionContainer.children.length === 0 && compositionText) {
                         const fallbackDiv = document.createElement('div');
                         fallbackDiv.classList.add('prompt-section');
                         const fallbackPre = document.createElement('pre');
                         fallbackPre.classList.add('prompt-section-content');
                         fallbackPre.textContent = compositionText.trim();
                         fallbackDiv.appendChild(fallbackPre);
                         compositionContainer.appendChild(fallbackDiv);
                    }

                    detailsDiv.appendChild(compositionContainer);
                    textDiv.appendChild(detailsDiv);
                } // End of if (message.prompt_composition)
            }

            avatarDiv.appendChild(avatarIcon);
            contentDiv.appendChild(avatarDiv);
            contentDiv.appendChild(textDiv);
            messageDiv.appendChild(contentDiv);

            chatMessagesContainer.appendChild(messageDiv);
        }

        function renderHistory(history) {
            // Selectively remove only message elements (user or assistant)
            const messagesToRemove = chatMessagesContainer.querySelectorAll('.message.user-message, .message.assistant-message');
            messagesToRemove.forEach(msg => msg.remove());

            loadingChatState.style.display = 'none'; // Hide loading indicator
            emptyChatState.classList.remove('empty-chat--visible'); // Ensure empty state is hidden initially

            // Check if history is truly empty (null, undefined, or empty array)
            if (!history || history.length === 0) {
                // Show empty state using the CSS class
                emptyChatTitle.textContent = `Welcome to Clone ${currentCloneName}`;
                emptyChatState.classList.add('empty-chat--visible'); // Explicitly add class only if needed
            } else {
                 // Render messages (empty state remains hidden)
                history.forEach(renderMessage); // renderMessage appends to chatMessagesContainer
            }
            scrollToBottom();
        }

        async function fetchSessionAndHistory() {
            loadingChatState.style.display = 'block';
            questionTextarea.disabled = true; // Keep disabled until ready
            sendButton.disabled = true;
            flashMessagesContainer.style.display = 'none';

            // --- Use Initial Info First ---
            if (!initialCloneId || !initialConversationId) { // <<< CHECK CONVERSATION ID TOO
                 console.error("No initial clone ID or conversation ID provided. Redirecting.");
                 // This shouldn't happen if the redirect worked, but as a fallback:
                 window.location.href = "{{ url_for('clone_directory') }}";
                 return;
            }

            currentConversationId = initialConversationId; // Use initial conversation ID
            currentCloneName = initialCloneName; // Use name passed from redirect
            document.title = `Clone ${currentCloneName} - Chat`;
            cloneNameHeader.textContent = currentCloneName;
            if (initialCloneRole) { // Use initial role
                roleTagHeader.textContent = initialCloneRole;
                roleTagHeader.style.display = 'block';
            } else {
                roleTagHeader.style.display = 'none';
            }

            // Enable input now that we have basic info
            questionTextarea.disabled = false;
            sendButton.disabled = false;
            questionTextarea.focus();

            // --- End Initial Info ---

            if (!backendApiUrl) {
                displayFlashMessage('Error: Backend API URL not configured.');
                loadingChatState.textContent = 'Error: Backend API not configured.';
                return; // Stop, but don't redirect
            }

            try {
                // Fetch session info primarily for HISTORY now
                console.log("Fetching session info (for history) from backend...");
                const sessionResponse = await fetch(`${backendApiUrl}/api/session_info`, { credentials: 'include' });

                if (!sessionResponse.ok) {
                     // Don't redirect, just log error and potentially show message
                     console.error(`Failed to fetch session info: ${sessionResponse.status}`);
                     displayFlashMessage(`Error ${sessionResponse.status}: Could not load chat session details. Please try refreshing or starting a new chat.`, 'error');
                     loadingChatState.style.display = 'none'; // Hide loading
                     renderHistory([]); // Show empty state
                     return; // Stop further execution in this block
                }

                const sessionInfo = await sessionResponse.json();
                console.log("Session info received:", sessionInfo);

                // Validate if the session clone/conversation matches the expected ones (optional but good)
                if (sessionInfo.active_clone_id !== initialCloneId || sessionInfo.conversation_id !== initialConversationId) {
                    console.warn(`Session info mismatch: Session(clone=${sessionInfo.active_clone_id}, conv=${sessionInfo.conversation_id}), Initial(clone=${initialCloneId}, conv=${initialConversationId}). Using initial conversation ID.`);
                    // Keep using initialConversationId set earlier
                }

                // Get history using the determined conversation ID (or attempt even if null, backend might handle)
                const history = sessionInfo.conversation_history || [];
                console.log(`Rendering history for conversation ID: ${currentConversationId}, History length: ${history.length}`);

                renderHistory(history); // Render history from session

            } catch (error) {
                console.error('Error fetching or processing chat session:', error);
                loadingChatState.style.display = 'none';
                displayFlashMessage(`Error loading chat session: ${error.message}. Please try refreshing.`, 'error');
                renderHistory([]); // Show empty state on error
            } finally {
                 // Ensure loading state is hidden even if errors occurred before renderHistory
                 loadingChatState.style.display = 'none';
            }
        }

        // Handle Form Submission (Send Message)
        chatForm.addEventListener('submit', async (event) => {
            console.log('[Submit Listener] Form submission triggered.'); // <<< ADD LOG HERE
            event.preventDefault();
            const question = questionTextarea.value.trim();
            // Removed: if (!question || !currentConversationId) { return; }

            // Optimistically render user message
            const userMessage = { role: 'user', content: question, timestamp: new Date().toLocaleString() };
            renderMessage(userMessage);
            scrollToBottom();

            // Clear input and disable form
            questionTextarea.value = '';
            questionTextarea.style.height = 'auto'; // Reset height
            questionTextarea.disabled = true;
            sendButton.disabled = true;

            // Optional: Show thinking indicator
            const thinkingDiv = document.createElement('div');
            thinkingDiv.className = 'message assistant-message thinking';
            thinkingDiv.innerHTML = '<div class="message-content"><div class="message-avatar"><i class="fas fa-robot"></i></div><div class="message-text"><p><i>Thinking...</i></p></div></div>';
            chatMessagesContainer.appendChild(thinkingDiv);
            scrollToBottom();


            try {
                const response = await fetch(`${backendApiUrl}/api/ask`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ question: question, clone_id: initialCloneId }), // <<< ADD CLONE ID
                    credentials: 'include'
                });

                // Remove thinking indicator regardless of success/failure
                const thinkingIndicator = chatMessagesContainer.querySelector('.thinking');
                if (thinkingIndicator) {
                    thinkingIndicator.remove();
                }

                const result = await response.json();

                if (response.ok) {
                    // The API now returns the full history, so re-render it
                    renderHistory(result.conversation_history || []);
                } else {
                    console.error('Error asking question:', result);
                    displayFlashMessage(result.error || 'Failed to get response from clone.', 'error');
                    // Optionally remove the optimistic user message or add an error indicator
                }

            } catch (error) {
                 // Remove thinking indicator on network error too
                const thinkingIndicator = chatMessagesContainer.querySelector('.thinking');
                if (thinkingIndicator) {
                    thinkingIndicator.remove();
                }
                console.error('Network or other error sending message:', error);
                displayFlashMessage('An network error occurred while sending your message.', 'error');
            } finally {
                // Re-enable form
                questionTextarea.disabled = false;
                sendButton.disabled = false;
                questionTextarea.focus();
            }
        });

        // Handle New Chat Button
        newChatButton.addEventListener('click', async () => {
            console.log("Starting new chat...");
            newChatButton.disabled = true; // Prevent double clicks
            flashMessagesContainer.style.display = 'none';

            if (!backendApiUrl) {
                 displayFlashMessage('Error: Backend API URL not configured.');
                 newChatButton.disabled = false;
                 return;
            }

            try {
                 const response = await fetch(`${backendApiUrl}/api/new_chat`, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     credentials: 'include'
                 });
                 const result = await response.json();

                 if (response.ok) {
                     console.log("New chat started:", result);
                     currentConversationId = result.conversation_id; // Update conversation ID
                     renderHistory([]); // Clear the chat display
                     questionTextarea.disabled = false; // Ensure input is enabled
                     sendButton.disabled = false;
                     questionTextarea.focus();
                 } else {
                     console.error("Failed to start new chat:", result);
                     displayFlashMessage(result.error || 'Failed to start new chat.', 'error');
                 }
            } catch (error) {
                 console.error("Network error starting new chat:", error);
                 displayFlashMessage('A network error occurred while starting a new chat.', 'error');
            } finally {
                 newChatButton.disabled = false;
            }
        });


        // --- Existing Textarea Utils ---
        questionTextarea.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
        });

        questionTextarea.addEventListener('keydown', function(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                console.log('[Keydown Listener] Enter pressed without Shift.'); // <<< ADD LOG HERE
                event.preventDefault();
                console.log('[Keydown Listener] Calling chatForm.requestSubmit().'); // <<< ADD LOG HERE
                chatForm.requestSubmit(); // Use requestSubmit for better form handling
            }
        });

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            // Add a small delay before fetching session info
            console.log('[Chat Interface] DOMContentLoaded fired. Waiting 100ms before fetching session...');
            setTimeout(fetchSessionAndHistory, 100); 
        });

    </script>
</body>
</html>
